/* Users can (dis)allow different groups of cookies. */
const COOKIE_CATEGORIES = {
    analytics: ['_ga', '_ga_' + window.GA_CONTAINER_ID],
    /* Essential cookies
     *
     * Essential cookies cannot be deselected, but we want our cookie code to
     * only allow adding cookies that are documented in this object, so they need
     * to be added here.
     */
    essential: [window.GA_COOKIE_NAME]
};
/*
 * Default cookie preferences if user has no cookie preferences.
 *
 * Note that this doesn't include a key for essential cookies, essential
 * cookies cannot be disallowed. If the object contains { essential: false }
 * this will be ignored.
 */
const DEFAULT_COOKIE_CONSENT = {
    analytics: false,
    version: window.GDS_CONSENT_COOKIE_VERSION
};
/** Return the user's cookie preferences.
 *
 * If the consent cookie is malformed, or not present,
 * returns null.
 */
function getConsentCookie() {
    const consentCookie = getCookie(window.GA_COOKIE_NAME);
    let consentCookieObj;
    if (consentCookie) {
        try {
            consentCookieObj = JSON.parse(consentCookie);
        }
        catch (err) {
            return null;
        }
    }
    else {
        return null;
    }
    return consentCookieObj;
}
/** Check the cookie preferences object.
 *
 * If the consent object is not present, malformed, or incorrect version,
 * returns false, otherwise returns true.
 */
function isValidConsentCookie(options) {
    return (options && options.version >= window.GDS_CONSENT_COOKIE_VERSION);
}
/** Update the user's cookie preferences. */
function setConsentCookie(options) {
    let cookieConsent = getConsentCookie();
    if (!cookieConsent) {
        cookieConsent = JSON.parse(JSON.stringify(DEFAULT_COOKIE_CONSENT));
    }
    // Merge current cookie preferences and new preferences
    for (var option in options) {
        cookieConsent[option] = options[option];
    }
    // Essential cookies cannot be deselected, ignore this cookie type
    delete cookieConsent.essential;
    cookieConsent.version = window.GDS_CONSENT_COOKIE_VERSION;
    // Set the consent cookie
    setCookie(window.GA_COOKIE_NAME, JSON.stringify(cookieConsent), { days: 365 });
    // Update the other cookies
    resetCookies();
}
/** Apply the user's cookie preferences
 *
 * Deletes any cookies the user has not consented to.
 */
function resetCookies() {
    var options = getConsentCookie();
    // If no preferences or old version use the default
    if (!isValidConsentCookie(options)) {
        options = JSON.parse(JSON.stringify(DEFAULT_COOKIE_CONSENT));
    }
    for (var cookieType in options) {
        if (cookieType === 'version') {
            continue;
        }
        // Essential cookies cannot be deselected, ignore this cookie type
        if (cookieType === 'essential') {
            continue;
        }
        if (!options[cookieType]) {
            // Fetch the cookies in that category
            var cookiesInCategory = COOKIE_CATEGORIES[cookieType];
            cookiesInCategory.forEach(function (cookie) {
                deleteCookie(cookie);
            });
        }
    }
}
function userAllowsCookieCategory(cookieCategory, cookiePreferences) {
    // Essential cookies are always allowed
    if (cookieCategory === 'essential') {
        return true;
    }
    // Sometimes cookiePreferences is malformed in some of the tests, so we need to handle these
    try {
        return cookiePreferences[cookieCategory];
    }
    catch (e) {
        console.error(e);
        return false;
    }
}
function userAllowsCookie(cookieName) {
    // Always allow setting the consent cookie
    if (cookieName === window.GA_COOKIE_NAME) {
        return true;
    }
    // Get the current cookie preferences
    var cookiePreferences = getConsentCookie();
    // If no preferences or old version use the default
    if (!isValidConsentCookie(cookiePreferences)) {
        cookiePreferences = DEFAULT_COOKIE_CONSENT;
    }
    for (var category in COOKIE_CATEGORIES) {
        var cookiesInCategory = COOKIE_CATEGORIES[category];
        if (cookiesInCategory.indexOf(cookieName) !== '-1') {
            return userAllowsCookieCategory(category, cookiePreferences);
        }
    }
    // Deny the cookie if it is not known to us
    return false;
}
function getCookie(name) {
    var nameEQ = name + '=';
    var cookies = document.cookie.split(';');
    for (var i = 0, len = cookies.length; i < len; i++) {
        var cookie = cookies[i];
        while (cookie.charAt(0) === ' ') {
            cookie = cookie.substring(1, cookie.length);
        }
        if (cookie.indexOf(nameEQ) === 0) {
            return decodeURIComponent(cookie.substring(nameEQ.length));
        }
    }
    return null;
}
// do we need to set the domain?
function setCookie(name, value, options) {
    if (userAllowsCookie(name)) {
        if (typeof options === 'undefined') {
            options = {};
        }
        var cookieString = name + '=' + value + '; path=/; SameSite=Strict';
        if (options.days) {
            var date = new Date();
            date.setTime(date.getTime() + (options.days * 24 * 60 * 60 * 1000));
            cookieString = cookieString + '; expires=' + date.toUTCString();
        }
        if (document.location.protocol === 'https:') {
            cookieString = cookieString + '; Secure';
        }
        document.cookie = cookieString;
    }
}
function deleteCookie(name) {
    if (getCookie(name)) {
        // Cookies need to be deleted in the same level of specificity in which they were set
        // If a cookie was set with a specified domain, it needs to be specified when deleted
        // If a cookie wasn't set with the domain attribute, it shouldn't be there when deleted
        // You can't tell if a cookie was set with a domain attribute or not, so try both options
        document.cookie = name + '=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/';
        document.cookie = name + '=;expires=Thu, 01 Jan 1970 00:00:00 GMT;domain=' + window.location.hostname + ';path=/';
        document.cookie = name + '=;expires=Thu, 01 Jan 1970 00:00:00 GMT;domain=.' + window.location.hostname + ';path=/';
    }
}

/*todo: remove this and use NodeList.prototype.forEach instead, as govuk has for v5 */
/* https://github.com/alphagov/govuk-frontend/issues/3466 */
/* https://github.com/alphagov/govuk-frontend/pull/3570/files */
function nodeListForEach(nodes, callback) {
    if (window.NodeList.prototype.forEach) {
        return nodes.forEach(callback);
    }
    for (var i = 0; i < nodes.length; i++) {
        callback.call(window, nodes[i], i, nodes);
    }
}

// from https://github.com/ideal-postcodes/postcode
/**
 * Tests for the inward code section of a postcode
 */
const INCODE_REGEX = /\d[a-z]{2}$/i;
/**
 * Tests for a valid postcode
 */
const POSTCODE_REGEX = /^[a-z]{1,2}\d[a-z\d]?\s*\d[a-z]{2}$/i;
const SPACE_REGEX = /\s+/gi;
/**
 * Drop all spaces and uppercase
 * @hidden
 */
const sanitize = (s) => s.replace(SPACE_REGEX, "").toUpperCase();
/**
 * Detects a "valid" postcode
 * - Starts and ends on a non-space character
 * - Any length of intervening space is allowed
 * - Must conform to one of following schemas:
 *  - AA1A 1AA
 *  - A1A 1AA
 *  - A1 1AA
 *  - A99 9AA
 *  - AA9 9AA
 *  - AA99 9AA
 */
const isValid = (postcode) => postcode.match(POSTCODE_REGEX) !== null;
/**
 * Returns a correctly formatted outcode given a postcode
 *
 * Returns null if invalid postcode
 */
const toOutcode = (postcode) => {
    if (!isValid(postcode))
        return null;
    return sanitize(postcode).replace(INCODE_REGEX, "");
};

//todo: consent mode debugging/check: https://developers.google.com/tag-platform/devguides/consent-debugging
function gtag(command, ...args) {
    window.dataLayer = window.dataLayer || [];
    window.dataLayer.push(arguments);
}
let GaMeasurementId = '';
//todo: use prototype? (or class?)
// (having an object (prototype/class) will ensure that GaMeasurementId will have already been set)
function initAnalytics(gaMeasurementId) {
    // if the environment doesn't have a measurement id, don't load analytics
    if (!Boolean(gaMeasurementId)) {
        return;
    }
    GaMeasurementId = gaMeasurementId;
    setDefaultConsent();
    loadGaScript(gaMeasurementId);
    gtag('js', new Date());
    const pageViewParams = getPiiSafePageView(gaMeasurementId);
    // set the config for auto generated events other than page_view
    gtag('config', gaMeasurementId, {
        send_page_view: false, //disable auto page_view measurement
        page_path: pageViewParams.page_path,
        page_location: pageViewParams.page_location,
        page_referrer: pageViewParams.referrer,
        cookie_flags: 'secure'
    });
    const userConsent = getConsentCookie();
    if (userConsent && isValidConsentCookie(userConsent) && userConsent.analytics) {
        updateAnalyticsStorageConsent(true);
    }
    sendPageViewEvent();
    sendFilterPageCustomEvent();
}
function setDefaultConsent() {
    gtag('consent', 'default', {
        'analytics_storage': 'denied'
    });
    gtag('set', 'url_passthrough', true);
}
function updateAnalyticsStorageConsent(granted, delayMs) {
    let options = {
        'analytics_storage': granted ? 'granted' : 'denied'
    };
    if (typeof delayMs !== 'undefined') {
        options['wait_for_update'] = delayMs;
    }
    gtag('consent', 'update', options);
}
function sendPageViewEvent() {
    // send the page_view event manually (https://developers.google.com/analytics/devguides/collection/gtagjs/pages#default_behavior)
    gtag('event', 'page_view', getPiiSafePageView(GaMeasurementId));
}
function sendFilterPageCustomEvent() {
    //todo: make filter page only
    const element = document.getElementById('results');
    const totalResults = element === null || element === void 0 ? void 0 : element.getAttribute('data-total-results');
    if (totalResults === undefined)
        return;
    gtag('event', 'filter_page', {
        'total_results': totalResults
    });
}
function sendAnalyticsCustomEvent(accepted, source) {
    gtag('event', 'analytics', {
        'accepted': accepted,
        'source': source
    });
}
function loadGaScript(gaMeasurementId) {
    const f = document.getElementsByTagName('script')[0];
    const j = document.createElement('script');
    j.async = true;
    j.src = 'https://www.googletagmanager.com/gtag/js?id=' + gaMeasurementId;
    f.parentNode.insertBefore(j, f);
}
function getPiiSafePageView(gaMeasurementId) {
    const pageView = {
        page_title: document.title,
        send_to: gaMeasurementId,
        referrer: '',
        page_location: '',
        page_path: ''
    };
    //todo: set as referrer or page_referrer in pageView - does it matter? is it only picking it up from the config?
    //todo: get piisafe referrer function
    if (document.referrer !== '') {
        const referrerUrl = new URL(document.referrer);
        const piiSafeReferrerQueryString = getPiiSafeQueryString(referrerUrl.search);
        if (piiSafeReferrerQueryString == null) {
            pageView.referrer = document.referrer;
        }
        else {
            const urlArray = document.referrer.split('?');
            pageView.referrer = urlArray[0] + piiSafeReferrerQueryString;
        }
    }
    const piiSafeQueryString = getPiiSafeQueryString(window.location.search);
    if (piiSafeQueryString == null) {
        pageView.page_location = window.location.href;
        pageView.page_path = window.location.pathname + window.location.search;
        return pageView;
    }
    const urlArray = window.location.href.split('?');
    pageView.page_location = urlArray[0] + piiSafeQueryString;
    pageView.page_path = window.location.pathname + piiSafeQueryString;
    return pageView;
}
function getPiiSafeQueryString(queryString) {
    //todo: for safety, convert to lowercase, so that if the user changes the case of the url, we still don't collect pii
    const queryParams = new URLSearchParams(queryString);
    let postcode = queryParams.get('postcode');
    if (postcode == null) {
        // null indicates original query params were already pii safe
        return null;
    }
    postcode = toOutcode(postcode);
    queryParams.set('postcode', postcode);
    queryParams.delete('latitude');
    queryParams.delete('longitude');
    return '?' + queryParams.toString();
}

const cookieBannerAcceptSelector = '.js-cookie-banner-accept';
const cookieBannerRejectSelector = '.js-cookie-banner-reject';
const cookieBannerHideButtonSelector = '.js-cookie-banner-hide';
const cookieMessageSelector = '.js-cookie-banner-message';
const cookieConfirmationAcceptSelector = '.js-cookie-banner-confirmation-accept';
const cookieConfirmationRejectSelector = '.js-cookie-banner-confirmation-reject';
function CookieBanner($module) {
    this.$module = $module;
}
CookieBanner.prototype.init = function () {
    this.$cookieBanner = this.$module;
    this.$acceptButton = this.$module.querySelector(cookieBannerAcceptSelector);
    this.$rejectButton = this.$module.querySelector(cookieBannerRejectSelector);
    this.$cookieMessage = this.$module.querySelector(cookieMessageSelector);
    this.$cookieConfirmationAccept = this.$module.querySelector(cookieConfirmationAcceptSelector);
    this.$cookieConfirmationReject = this.$module.querySelector(cookieConfirmationRejectSelector);
    this.$cookieBannerHideButtons = this.$module.querySelectorAll(cookieBannerHideButtonSelector);
    // Exit if no cookie banner module
    // or if we're on the cookies page to avoid circular journeys
    if (!this.$cookieBanner || this.onCookiesPage()) {
        return;
    }
    // Show the cookie banner to users who have not consented or have an
    // outdated consent cookie
    var currentConsentCookie = getConsentCookie();
    if (!currentConsentCookie || !isValidConsentCookie(currentConsentCookie)) {
        // If the consent cookie version is not valid, we need to remove any cookies which have been
        // set previously
        resetCookies();
        this.$cookieBanner.removeAttribute('hidden');
    }
    this.$acceptButton.addEventListener('click', this.acceptCookies.bind(this));
    this.$rejectButton.addEventListener('click', this.rejectCookies.bind(this));
    nodeListForEach(this.$cookieBannerHideButtons, function ($cookieBannerHideButton) {
        $cookieBannerHideButton.addEventListener('click', this.hideBanner.bind(this));
    }.bind(this));
};
CookieBanner.prototype.hideBanner = function () {
    this.$cookieBanner.setAttribute('hidden', true);
};
CookieBanner.prototype.acceptCookies = function () {
    // Do actual cookie consent bit
    setConsentCookie({ analytics: true });
    updateAnalyticsStorageConsent(true);
    sendAnalyticsCustomEvent(true, 'banner');
    sendPageViewEvent();
    sendFilterPageCustomEvent();
    // Hide banner and show confirmation message
    this.$cookieMessage.setAttribute('hidden', true);
    this.revealConfirmationMessage(this.$cookieConfirmationAccept);
};
CookieBanner.prototype.rejectCookies = function () {
    updateAnalyticsStorageConsent(true);
    sendAnalyticsCustomEvent(false, 'banner');
    updateAnalyticsStorageConsent(false);
    //setTimeout(CookieFunctions.setConsentCookie.bind({ analytics: false }), 250);
    setConsentCookie({ analytics: false });
    // Hide banner and show confirmation message
    this.$cookieMessage.setAttribute('hidden', true);
    this.revealConfirmationMessage(this.$cookieConfirmationReject);
};
CookieBanner.prototype.revealConfirmationMessage = function (confirmationMessage) {
    confirmationMessage.removeAttribute('hidden');
    // Set tabindex to -1 to make the confirmation banner focusable with JavaScript
    if (!confirmationMessage.getAttribute('tabindex')) {
        confirmationMessage.setAttribute('tabindex', '-1');
        confirmationMessage.addEventListener('blur', function () {
            confirmationMessage.removeAttribute('tabindex');
        });
    }
    confirmationMessage.focus();
};
CookieBanner.prototype.onCookiesPage = function () {
    return window.location.pathname === '/cookies/';
};

function CookiesPage($module) {
    this.$module = $module;
}
CookiesPage.prototype.init = function () {
    this.$cookiePage = this.$module;
    if (!this.$cookiePage) {
        return;
    }
    this.$cookieForm = this.$cookiePage.querySelector('.js-cookies-page-form');
    this.$cookieFormFieldsets = this.$cookieForm.querySelectorAll('.js-cookies-page-form-fieldset');
    this.$successNotification = this.$cookiePage.querySelector('.js-cookies-page-success');
    this.$successLink = this.$cookiePage.querySelector('.js-cookies-page-success-link');
    nodeListForEach(this.$cookieFormFieldsets, function ($cookieFormFieldset) {
        this.showUserPreference($cookieFormFieldset, getConsentCookie());
        /*        $cookieFormFieldset.removeAttribute('hidden')*/
    }.bind(this));
    // Show submit button
    //this.$cookieForm.querySelector('.js-cookies-form-button').removeAttribute('hidden')
    this.$cookieForm.addEventListener('submit', this.savePreferences.bind(this));
};
CookiesPage.prototype.savePreferences = function (event) {
    // Stop default form submission behaviour
    event.preventDefault();
    var preferences = {};
    nodeListForEach(this.$cookieFormFieldsets, function ($cookieFormFieldset) {
        var cookieType = this.getCookieType($cookieFormFieldset);
        var selectedItem = $cookieFormFieldset.querySelector('input[name=' + cookieType + ']:checked').value;
        preferences[cookieType] = selectedItem === 'true';
    }.bind(this));
    updateAnalyticsStorageConsent(true);
    const analyticsAccepted = preferences['analytics'];
    sendAnalyticsCustomEvent(analyticsAccepted, 'cookies');
    if (analyticsAccepted) {
        sendPageViewEvent();
    }
    else {
        updateAnalyticsStorageConsent(false);
    }
    setConsentCookie(preferences);
    // handle the corner case, where the user has selected their preference on the cookie page, whilst the banner is still open as they haven't previously selected their preference
    //todo: call hideBanner
    var banner = document.querySelector('[data-module="govuk-cookie-banner"]');
    banner.setAttribute('hidden', 'true');
    this.showSuccessNotification();
};
CookiesPage.prototype.showUserPreference = function ($cookieFormFieldset, preferences) {
    var cookieType = this.getCookieType($cookieFormFieldset);
    var preference = false;
    if (cookieType && preferences && preferences[cookieType] !== undefined) {
        preference = preferences[cookieType];
    }
    var radioValue = preference ? 'true' : 'false';
    var radio = $cookieFormFieldset.querySelector('input[name=' + cookieType + '][value=' + radioValue + ']');
    radio.checked = true;
};
CookiesPage.prototype.showSuccessNotification = function () {
    this.$successNotification.removeAttribute('hidden');
    // if the user's come to the cookies page through the link in the cookie banner, show a link to take them back to the page they came from
    //todo: use full url?
    var referrer = document.referrer ? new URL(document.referrer).pathname : false;
    if (referrer && referrer !== document.location.pathname) {
        this.$successLink.href = referrer;
        this.$successLink.removeAttribute('hidden');
    }
    else {
        this.$successLink.setAttribute('hidden', 'true');
    }
    // Set tabindex to -1 to make the element focusable with JavaScript.
    // GOV.UK Frontend will remove the tabindex on blur as the component doesn't
    // need to be focusable after the user has read the text.
    if (!this.$successNotification.getAttribute('tabindex')) {
        this.$successNotification.setAttribute('tabindex', '-1');
    }
    this.$successNotification.focus();
    // scroll to the top of the page
    window.scrollTo(0, 0);
};
CookiesPage.prototype.getCookieType = function ($cookieFormFieldset) {
    return $cookieFormFieldset.id;
};

// A version of the MOJ's add-another component that plays nice with the accessible autocomplete component.
// I did consider subclassing the MOJ's add-another component,
// but it would have been so coupled that it would've probably broken on an update of the MOJ library.
// So instead we forked it and made our own version.
window.FamilyHubsFrontend = window.FamilyHubsFrontend || {};
function initializeAddAnother() {
    //todo: support options with scope?
    var $addAnothers = document.querySelectorAll('[data-module="fh-add-another"]');
    $addAnothers.forEach(function ($addAnother) {
        new window.FamilyHubsFrontend.AddAnother($addAnother);
    });
}
window.FamilyHubsFrontend.AddAnother = function (container) {
    this.container = $(container);
    if (this.container.data('fh-add-another-initialised')) {
        return;
    }
    //todo: this is a bit hacky - find a better way to do this
    var functionName = container.getAttribute('data-fh-add-another-callback');
    this.callback = null;
    document.addEventListener('DOMContentLoaded', function () {
        if (typeof window[functionName] === 'function') {
            this.callback = window[functionName];
            this.callback(container);
        }
    }.bind(this));
    this.container.data('fh-add-another-initialised', true);
    this.container.on('click', '.fh-add-another__remove-button', $.proxy(this, 'onRemoveButtonClick'));
    this.container.on('click', '.fh-add-another__add-button', $.proxy(this, 'onAddButtonClick'));
    this.container.find('.fh-add-another__add-button, fh-add-another__remove-button').prop('type', 'button');
};
window.FamilyHubsFrontend.AddAnother.prototype.onAddButtonClick = function (e) {
    var item = this.getNewItem();
    this.resetItem(item);
    var firstItem = this.getItems().first();
    if (!this.hasRemoveButton(firstItem)) {
        this.createRemoveButton(firstItem);
    }
    this.getItems().last().after(item);
    item.find('input, textarea, select').first().focus();
};
window.FamilyHubsFrontend.AddAnother.prototype.hasRemoveButton = function (item) {
    return item.find('.fh-add-another__remove-button').length;
};
window.FamilyHubsFrontend.AddAnother.prototype.getItems = function () {
    return this.container.find('.fh-add-another__item');
};
window.FamilyHubsFrontend.AddAnother.prototype.getNewItem = function () {
    // get the first item and clone it
    const items = this.getItems();
    const item = items[0].cloneNode(true);
    // find the autocomplete wrappers and remove the elements that are added by accessible-autocomplete
    const autocompleteWrappers = item.querySelectorAll('.autocomplete__wrapper');
    autocompleteWrappers.forEach(wrapper => {
        if (wrapper.parentNode.parentNode) {
            wrapper.parentNode.parentNode.removeChild(wrapper.parentNode);
        }
    });
    var $item = $(item);
    // update the id and name attributes
    this.updateAttributes(items.length, $item);
    // call the callback which needs to apply accessibility-autocomplete enhancements to the new item
    if (typeof this.callback === 'function') {
        this.callback(item);
    }
    // Create a remove button if it doesn't exist
    if (!this.hasRemoveButton($item)) {
        this.createRemoveButton($item);
    }
    return $item;
};
window.FamilyHubsFrontend.AddAnother.prototype.updateAttributes = function (index, item) {
    item.find('[data-name]').each(function (i, el) {
        var originalId = el.id;
        el.name = $(el).attr('data-name').replace(/%index%/, index);
        el.id = $(el).attr('data-id').replace(/%index%/, index);
        var label = $(el).siblings('label')[0] || $(el).parents('label')[0] || item.find('[for="' + originalId + '"]')[0];
        label.htmlFor = el.id;
    });
};
window.FamilyHubsFrontend.AddAnother.prototype.createRemoveButton = function (item) {
    item.append('<button type="button" class="govuk-button govuk-button--secondary fh-add-another__remove-button">Remove</button>');
};
window.FamilyHubsFrontend.AddAnother.prototype.resetItem = function (item) {
    // accessibile-autocomplete adds an input (without data-name or data-id)
    // so we blank all input controls
    item.find('input, textarea, select').each(function (index, el) {
        if (el.type == 'checkbox' || el.type == 'radio') {
            el.checked = false;
        }
        else {
            el.value = '';
        }
    });
};
window.FamilyHubsFrontend.AddAnother.prototype.onRemoveButtonClick = function (e) {
    $(e.currentTarget).parents('.fh-add-another__item').remove();
    var items = this.getItems();
    if (items.length === 1) {
        items.find('.fh-add-another__remove-button').remove();
    }
    //todo: use bind instead of proxy
    items.each($.proxy(function (index, el) {
        this.updateAttributes(index, $(el));
    }, this));
    this.focusHeading();
};
window.FamilyHubsFrontend.AddAnother.prototype.focusHeading = function () {
    this.container.find('.fh-add-another__heading').focus();
};

function initializeBackButtons() {
    // Check if the page wasn't opened in a new tab or a standalone window
    if (history.length > 1) {
        const backLinks = document.querySelectorAll(".fh-back-link");
        nodeListForEach(backLinks, (link) => {
            link.style.display = "block";
            // Add an event listener to handle the back button click
            link.addEventListener("click", () => {
                // Go back to the previous page in the browser's history
                window.history.back();
            });
        });
    }
}

function initializeVisibilityToggles() {
    const visibilityToggles = document.querySelectorAll("[data-toggle-visibility-id]");
    nodeListForEach(visibilityToggles, (toggle) => {
        toggle.addEventListener('click', function handleClick(event) {
            let toToggleId = toggle.getAttribute("data-toggle-visibility-id");
            if (toToggleId) {
                let toToggle = document.getElementById(toToggleId);
                if (toToggle) {
                    if (toToggle.style.display === "none") {
                        toToggle.style.display = "block";
                    }
                    else {
                        toToggle.style.display = "none";
                    }
                }
            }
        });
    });
}

//todo: make it a standard govuk module?
//import { GOVUKFrontendComponent } from '../../govuk-frontend-component.mjs'
/*todo: rename fh-open-close-target-user-opened fh-open-close-target-open-non-desktop or somesuch */
class OpenCloseButton {
    constructor(openCloseButton) {
        //super();
        //if (!(openCloseButton instanceof HTMLButtonElement)) {
        //}
        this.openCloseButton = openCloseButton;
        const targetId = this.openCloseButton.getAttribute('data-open-close-mobile');
        this.target = document.getElementById(targetId);
        this.showText = this.openCloseButton.textContent;
        this.hideText = this.openCloseButton.getAttribute('data-open-close-mobile-hide');
        this.target.classList.add('fh-open-close-target');
        let defaultTargetVisibility = this.openCloseButton.getAttribute('data-open-close-mobile-default');
        if (defaultTargetVisibility === "hide") {
            this.hideTarget();
        }
        else {
            this.showTarget();
        }
        this.openCloseButton.addEventListener('click', (event) => this.handleClick(event));
    }
    handleClick(event) {
        if (this.target.classList.contains('fh-open-close-target-user-opened')) {
            this.hideTarget();
        }
        else {
            this.showTarget();
        }
    }
    showTarget() {
        if (this.target) {
            if (!this.target.classList.contains('fh-open-close-target-user-opened')) {
                this.target.classList.add('fh-open-close-target-user-opened');
            }
        }
        if (this.hideText) {
            this.openCloseButton.textContent = this.hideText;
        }
    }
    hideTarget() {
        if (this.target) {
            this.target.classList.remove('fh-open-close-target-user-opened');
        }
        if (this.showText) {
            this.openCloseButton.textContent = this.showText;
        }
    }
}

// js components were originally snaffled from https://github.com/alphagov/govuk-design-system/blob/main/src/javascripts/components/
//todo: consistency in module/proto/class style
window.FamilyHubsFrontend = window.FamilyHubsFrontend || {};
window.FamilyHubsFrontend.initAll = () => {
    // Initialise cookie banner
    const $cookieBanner = document.querySelector('[data-module="govuk-cookie-banner"]');
    new CookieBanner($cookieBanner).init();
    initAnalytics(window.GA_MEASUREMENT_ID);
    //todo: move this into scripts section on cookie page
    // Initialise cookie page
    var $cookiesPage = document.querySelector('[data-module="fh-cookies-page"]');
    new CookiesPage($cookiesPage).init();
    initializeBackButtons();
    initializeVisibilityToggles();
    initializeAddAnother();
    // initialise open close buttons
    let openCloseButtons = document.querySelectorAll('button[data-open-close-mobile]');
    openCloseButtons === null || openCloseButtons === void 0 ? void 0 : openCloseButtons.forEach((openCloseButton) => {
        new OpenCloseButton(openCloseButton);
    });
};
//todo: do we want to do this...
//document.addEventListener("DOMContentLoaded", function () {
window.GOVUKFrontend.initAll();
window.MOJFrontend.initAll();
window.FamilyHubsFrontend.initAll();
